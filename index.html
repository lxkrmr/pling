<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>pling!</title>
  <link rel="manifest" href="manifest.json">
  <meta name="theme-color" content="#0d1117">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="apple-mobile-web-app-title" content="pling!">
  <link rel="apple-touch-icon" href="icon.svg">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background: #0d1117;
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    canvas {
      display: block;
    }
  </style>
</head>
<body>
  <canvas id="game"></canvas>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    // ─── Constants ───────────────────────────────────────────────────────────────

    const CARD_WIDTH = 100;
    const CARD_HEIGHT = 140;
    const CARD_GAP = 20;
    const BUTTON_WIDTH = 200;
    const BUTTON_HEIGHT = 56;
    const BELL_RADIUS = 60;
    const CARD_INTERVAL = 1000; // ms between cards
    const FEEDBACK_DURATION = 1000; // ms to show correct/wrong

    const FONT_MONO = '"SF Mono", Monaco, Inconsolata, "Fira Code", monospace';
    const COLOR_BG      = '#0d1117'; // github dark background
    const COLOR_SURFACE = '#161b22'; // cards, button fills
    const COLOR_BORDER  = '#30363d'; // borders
    const COLOR_FG      = '#e6edf3'; // primary text
    const COLOR_MUTED   = '#8b949e'; // secondary text
    const COLOR_SUBTLE  = '#6e7681'; // muted text
    const COLOR_CORRECT = '#388bfd'; // correct – colorblind safe blue
    const COLOR_WRONG   = '#e3b341'; // wrong   – colorblind safe orange
    const COLOR_RED     = '#f85149'; // hearts only

    // ─── Symbols ─────────────────────────────────────────────────────────────────

    const SYMBOLS = ['●', '■', '▲'];

    // ─── State ───────────────────────────────────────────────────────────────────

    // gameState: 'menu' | 'countdown' | 'playing' | 'feedback' | 'gameover'
    let gameState = 'menu';
    let countdownValue = 3;
    let countdownTimer = null;
    let currentStackIndex = 0;
    let stacks = [null, null, null];
    let gameLoop = null;
    let lastResult = null; // 'correct' | 'wrong'
    let lives = 3;
    let score = 0;
    let highScore = parseInt(localStorage.getItem('highScore') || '0', 10);

    const MAX_LIVES = 3;
    const IS_STANDALONE = window.matchMedia('(display-mode: standalone)').matches;

    // ─── Card flashes ────────────────────────────────────────────────────────────

    let cardFlashes = []; // { index, opacity }

    function addCardFlash(index) {
      cardFlashes = cardFlashes.filter(f => f.index !== index);
      cardFlashes.push({ index, opacity: 1 });
    }

    function updateCardFlashes() {
      cardFlashes = cardFlashes.filter(f => f.opacity > 0);
      for (const f of cardFlashes) {
        f.opacity -= 0.04;
      }
    }

    function getCardFlash(index) {
      return cardFlashes.find(f => f.index === index) || null;
    }

    // ─── Ripples ─────────────────────────────────────────────────────────────────

    let ripples = [];

    function addRipple(x, y) {
      ripples.push({ x, y, radius: BELL_RADIUS, opacity: 0.8 });
    }

    function updateRipples() {
      ripples = ripples.filter(r => r.opacity > 0);
      for (const r of ripples) {
        r.radius += 4;
        r.opacity -= 0.025;
      }
    }

    function drawRipples() {
      for (const r of ripples) {
        ctx.beginPath();
        ctx.arc(r.x, r.y, r.radius, 0, Math.PI * 2);
        ctx.strokeStyle = `rgba(255, 255, 255, ${r.opacity})`;
        ctx.lineWidth = 1.5;
        ctx.stroke();
      }
    }

    // ─── Layout ──────────────────────────────────────────────────────────────────

    function getLayout() {
      const totalCardsWidth = 3 * CARD_WIDTH + 2 * CARD_GAP;
      const cx = canvas.width / 2;
      const cy = canvas.height / 2;

      // Cards sit above center
      const cardsY = cy - CARD_HEIGHT - 20;
      const cardsStartX = cx - totalCardsWidth / 2;

      // Bell sits below cards
      const bellY = cardsY + CARD_HEIGHT + 40 + BELL_RADIUS;

      return {
        cx,
        cy,
        cards: [
          { x: cardsStartX, y: cardsY },
          { x: cardsStartX + CARD_WIDTH + CARD_GAP, y: cardsY },
          { x: cardsStartX + 2 * (CARD_WIDTH + CARD_GAP), y: cardsY }
        ],
        bell: { x: cx, y: bellY, radius: BELL_RADIUS },
        menuButton: {
          x: cx - BUTTON_WIDTH / 2,
          y: cy + 120,
          width: BUTTON_WIDTH,
          height: BUTTON_HEIGHT
        },
        closeButton: { x: canvas.width - 56, y: 20, size: 36 }
      };
    }

    // ─── Draw helpers ────────────────────────────────────────────────────────────

    function clearCanvas() {
      ctx.fillStyle = COLOR_BG;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
    }

    function drawText(text, x, y, { size = 24, color = COLOR_FG, align = 'center', baseline = 'middle' } = {}) {
      ctx.fillStyle = color;
      ctx.font = `${size}px ${FONT_MONO}`;
      ctx.textAlign = align;
      ctx.textBaseline = baseline;
      ctx.fillText(text, x, y);
    }

    function drawRect(x, y, w, h, { fill = COLOR_SURFACE, stroke = COLOR_BORDER, lineWidth = 1 } = {}) {
      ctx.fillStyle = fill;
      ctx.fillRect(x, y, w, h);
      ctx.strokeStyle = stroke;
      ctx.lineWidth = lineWidth;
      ctx.strokeRect(x, y, w, h);
    }

    // ─── Draw screens ────────────────────────────────────────────────────────────

    function drawMenu() {
      const layout = getLayout();
      clearCanvas();

      // Title
      drawText('pling!', layout.cx, layout.cy - 110, { size: 72 });

      // How to play
      drawText('count symbols across all cards', layout.cx, layout.cy - 35, { size: 13, color: COLOR_MUTED });
      drawText('spot exactly 5 of a kind → PLING!', layout.cx, layout.cy - 14, { size: 13, color: COLOR_MUTED });
      // Draw "wrong press → lose a heart" + red heart separately
      const prefix = 'wrong press → lose a heart ';
      const heart = '♥';
      ctx.font = `13px ${FONT_MONO}`;
      const totalWidth = ctx.measureText(prefix + heart).width;
      const textStartX = layout.cx - totalWidth / 2;
      ctx.textAlign = 'left';
      ctx.textBaseline = 'middle';
      ctx.fillStyle = COLOR_MUTED;
      ctx.fillText(prefix, textStartX, layout.cy + 7);
      ctx.fillStyle = COLOR_RED;
      ctx.fillText(heart, textStartX + ctx.measureText(prefix).width, layout.cy + 7);

      // High score
      drawText('how many can you get?', layout.cx, layout.cy + 45, { size: 13, color: COLOR_SUBTLE });
      drawText(`best: ${highScore}`, layout.cx, layout.cy + 68, { size: 20, color: COLOR_MUTED });

      // Start button – inverted
      const btn = layout.menuButton;
      ctx.fillStyle = COLOR_FG;
      ctx.fillRect(btn.x, btn.y, btn.width, btn.height);
      drawText('start', btn.x + btn.width / 2, btn.y + btn.height / 2, { color: COLOR_BG });

      // PWA hint – only when not already installed
      if (!IS_STANDALONE) {
        drawText('add to home screen for the best experience', layout.cx, canvas.height - 28, { size: 11, color: COLOR_SUBTLE });
      }
    }

    function drawCountdown() {
      const layout = getLayout();
      clearCanvas();

      drawText(String(countdownValue), layout.cx, layout.cy, { size: 128 });
    }

    function drawCard(x, y, card, index) {
      // Border only when empty, subtle fill when card present
      drawRect(x, y, CARD_WIDTH, CARD_HEIGHT, {
        fill: card ? COLOR_SURFACE : COLOR_BG,
        stroke: card ? COLOR_BORDER : '#21262d',
        lineWidth: 1
      });

      if (card) {
        const padding = 28;
        const cx = x + CARD_WIDTH / 2;
        const cy = y + CARD_HEIGHT / 2;
        const ox = CARD_WIDTH / 2 - padding;
        const oy = CARD_HEIGHT / 2 - padding;

        // Dice-style positions
        const positions = {
          1: [[0, 0]],
          2: [[-ox, -oy], [ox, oy]],
          3: [[-ox, -oy], [0, 0], [ox, oy]],
          4: [[-ox, -oy], [ox, -oy], [-ox, oy], [ox, oy]]
        };

        for (const [dx, dy] of positions[card.count]) {
          drawText(card.symbol, cx + dx, cy + dy, { size: 20 });
        }
      }

      // Flash highlight when card was just updated
      const flash = getCardFlash(index);
      if (flash) {
        ctx.strokeStyle = `rgba(255, 255, 255, ${flash.opacity})`;
        ctx.lineWidth = 2;
        ctx.strokeRect(x, y, CARD_WIDTH, CARD_HEIGHT);
      }
    }

    function drawBell(bell) {
      // Determine color based on state
      let fill = COLOR_SURFACE;
      let stroke = COLOR_BORDER;
      let labelColor = COLOR_FG;
      let label = 'pling!';
      let labelSize = 18;

      if (gameState === 'feedback') {
        if (lastResult === 'correct') {
          fill = '#0d1f3c';
          stroke = COLOR_CORRECT;
          label = '✓';
          labelColor = COLOR_CORRECT;
          labelSize = 32;
        } else {
          fill = '#2d1f0a';
          stroke = COLOR_WRONG;
          label = '✗';
          labelColor = COLOR_WRONG;
          labelSize = 32;
        }
      }

      // Circle
      ctx.beginPath();
      ctx.arc(bell.x, bell.y, bell.radius, 0, Math.PI * 2);
      ctx.fillStyle = fill;
      ctx.fill();
      ctx.strokeStyle = stroke;
      ctx.lineWidth = 1.5;
      ctx.stroke();

      // Label
      ctx.font = `${labelSize}px ${FONT_MONO}`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillStyle = labelColor;
      ctx.fillText(label, bell.x, bell.y);
    }

    function drawLives() {
      const full = '♥';
      const empty = '♡';
      let hearts = '';
      for (let i = 0; i < MAX_LIVES; i++) {
        hearts += i < lives ? full : empty;
        if (i < MAX_LIVES - 1) hearts += ' ';
      }
      drawText(hearts, 20, 36, { size: 20, color: COLOR_RED, align: 'left' });
    }

    function drawGame() {
      const layout = getLayout();
      clearCanvas();

      // Cards
      for (let i = 0; i < 3; i++) {
        drawCard(layout.cards[i].x, layout.cards[i].y, stacks[i], i);
      }

      // Ripples (behind bell)
      drawRipples();

      // Bell
      drawBell(layout.bell);

      // Close button
      drawRect(layout.closeButton.x, layout.closeButton.y, layout.closeButton.size, layout.closeButton.size, {
        fill: COLOR_BG,
        stroke: COLOR_BORDER
      });
      drawText('×', layout.closeButton.x + layout.closeButton.size / 2, layout.closeButton.y + layout.closeButton.size / 2, { size: 18, color: COLOR_MUTED });

      // Lives (top left)
      drawLives();

      // Score (top center)
      drawText(`${score}`, layout.cx, 36, { size: 20, color: COLOR_SUBTLE });
    }

    function drawGameOver() {
      const layout = getLayout();
      clearCanvas();

      drawText('game over', layout.cx, layout.cy - 90, { size: 36 });
      drawText(`score: ${score}`, layout.cx, layout.cy - 20, { size: 28 });

      if (score > 0 && score === highScore) {
        drawText('new record!', layout.cx, layout.cy + 25, { size: 14, color: COLOR_CORRECT });
      } else {
        drawText(`best: ${highScore}`, layout.cx, layout.cy + 25, { size: 14, color: COLOR_SUBTLE });
      }

      // Back to menu button – inverted
      const btn = layout.menuButton;
      ctx.fillStyle = COLOR_FG;
      ctx.fillRect(btn.x, btn.y, btn.width, btn.height);
      drawText('menu', btn.x + btn.width / 2, btn.y + btn.height / 2, { color: COLOR_BG });
    }

    // ─── Main draw ───────────────────────────────────────────────────────────────

    function draw() {
      if (gameState === 'menu') {
        drawMenu();
      } else if (gameState === 'countdown') {
        drawCountdown();
      } else if (gameState === 'playing' || gameState === 'feedback') {
        drawGame();
      } else if (gameState === 'gameover') {
        drawGameOver();
      }
    }

    // ─── Animation loop ──────────────────────────────────────────────────────────

    function loop() {
      updateRipples();
      updateCardFlashes();
      draw();
      requestAnimationFrame(loop);
    }

    // ─── Game logic ──────────────────────────────────────────────────────────────

    function randomCard() {
      const symbol = SYMBOLS[Math.floor(Math.random() * SYMBOLS.length)];
      const count = Math.floor(Math.random() * 4) + 1; // 1–4
      return { symbol, count };
    }

    function addNextCard() {
      addCardFlash(currentStackIndex);
      stacks[currentStackIndex] = randomCard();
      currentStackIndex = (currentStackIndex + 1) % 3;
    }

    function countSymbols() {
      const counts = {};
      for (const s of SYMBOLS) counts[s] = 0;
      for (const card of stacks) {
        if (card) counts[card.symbol] += card.count;
      }
      return counts;
    }

    function hasExactlyFive() {
      const counts = countSymbols();
      return SYMBOLS.some(s => counts[s] === 5);
    }

    // ─── Transitions ─────────────────────────────────────────────────────────────

    function goToMenu() {
      if (gameLoop) { clearInterval(gameLoop); gameLoop = null; }
      if (countdownTimer) { clearInterval(countdownTimer); countdownTimer = null; }
      ripples = [];
      cardFlashes = [];
      stacks = [null, null, null];
      currentStackIndex = 0;
      lastResult = null;
      gameState = 'menu';
    }

    function goToGameOver() {
      if (gameLoop) { clearInterval(gameLoop); gameLoop = null; }
      if (score > highScore) {
        highScore = score;
        localStorage.setItem('highScore', highScore);
      }
      gameState = 'gameover';
    }

    function startCountdown() {
      gameState = 'countdown';
      countdownValue = 3;
      lives = MAX_LIVES;
      score = 0;

      countdownTimer = setInterval(() => {
        countdownValue--;
        if (countdownValue === 0) {
          clearInterval(countdownTimer);
          countdownTimer = null;
          startPlaying();
        }
      }, 1000);
    }

    function startPlaying() {
      gameState = 'playing';
      stacks = [null, null, null];
      currentStackIndex = 0;
      gameLoop = setInterval(addNextCard, CARD_INTERVAL);
    }

    function checkPling(x, y) {
      if (gameLoop) { clearInterval(gameLoop); gameLoop = null; }

      lastResult = hasExactlyFive() ? 'correct' : 'wrong';
      if (lastResult === 'correct') score++;
      if (lastResult === 'wrong') lives--;

      addRipple(x, y);

      gameState = 'feedback';

      setTimeout(() => {
        if (lives === 0) {
          goToGameOver();
        } else {
          startPlaying();
        }
      }, FEEDBACK_DURATION);
    }

    // ─── Input ───────────────────────────────────────────────────────────────────

    function isInside(x, y, rect) {
      return x >= rect.x && x <= rect.x + (rect.width || rect.size) &&
             y >= rect.y && y <= rect.y + (rect.height || rect.size);
    }

    function isInsideBell(x, y, bell) {
      const dx = x - bell.x;
      const dy = y - bell.y;
      return Math.sqrt(dx * dx + dy * dy) <= bell.radius;
    }

    function handlePress(x, y) {
      const layout = getLayout();

      if (gameState === 'menu') {
        if (isInside(x, y, layout.menuButton)) startCountdown();

      } else if (gameState === 'playing') {
        if (isInside(x, y, layout.closeButton)) goToMenu();
        else if (isInsideBell(x, y, layout.bell)) checkPling(layout.bell.x, layout.bell.y);

      } else if (gameState === 'gameover') {
        if (isInside(x, y, layout.menuButton)) goToMenu();
      }
    }

    canvas.addEventListener('click', (e) => handlePress(e.clientX, e.clientY));

    canvas.addEventListener('touchstart', (e) => {
      e.preventDefault();
      const t = e.touches[0];
      handlePress(t.clientX, t.clientY);
    });

    window.addEventListener('resize', () => {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    });

    // ─── Init ────────────────────────────────────────────────────────────────────

    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    loop();

    // Register service worker for PWA / offline support
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('./sw.js');
    }
  </script>
</body>
</html>
