<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>pling!</title>
  <link rel="manifest" href="manifest.json">
  <meta name="theme-color" content="#0d1117">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="apple-mobile-web-app-title" content="pling!">
  <link rel="apple-touch-icon" href="icon.svg">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    html, body {
      overflow: hidden;
      height: 100%;
    }

    body {
      background: #0d1117;
      min-height: 100dvh;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    canvas {
      display: block;
      border-radius: 12px;
      box-shadow: 0 0 0 1px #30363d;
      touch-action: none;
    }

    @media (max-width: 430px) {
      canvas {
        border-radius: 0;
        box-shadow: none;
      }
    }
  </style>
</head>
<body>
  <canvas id="game"></canvas>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    // ─── Constants ───────────────────────────────────────────────────────────────

    const CARD_WIDTH = 80;
    const CARD_HEIGHT = 120;
    const CARD_GAP = 12;
    const STACK_COUNT = 4;
    const UNLOCK_THRESHOLDS = [3, 15]; // score to unlock stack 3, 4
    const BUTTON_WIDTH = 200;
    const BUTTON_HEIGHT = 56;
    const BELL_RADIUS = 60;
    const BASE_INTERVAL = 1200;  // ms between cards at score 0
    const MIN_INTERVAL  = 500;   // fastest possible
    const FEEDBACK_DURATION = 1000; // ms to show correct/wrong

    const FONT_MONO = '"SF Mono", Monaco, Inconsolata, "Fira Code", monospace';
    const COLOR_BG      = '#0d1117';
    const COLOR_SURFACE = '#161b22';
    const COLOR_BORDER  = '#30363d';
    const COLOR_FG      = '#e6edf3';
    const COLOR_MUTED   = '#8b949e';
    const COLOR_SUBTLE  = '#6e7681';
    const COLOR_CORRECT = '#388bfd';
    const COLOR_WRONG   = '#e3b341';
    const COLOR_RED     = '#f85149';

    // ─── Language ────────────────────────────────────────────────────────────────

    let lang = localStorage.getItem('lang') ||
               (navigator.language.startsWith('de') ? 'de' : 'en');

    const T = {
      en: {
        // menu
        howTo1:       'count symbols across all cards',
        howTo2:       'spot exactly 5 of a kind → PLING!',
        howTo3prefix: 'wrong press → lose a heart ',
        tagline:      'how many can you get?',
        best:         n => `best: ${n}`,
        start:        'start',
        // countdown
        ready:        'ready?',
        go:           'go!',
        // game
        rule:         'exactly 5 of a kind → pling!',
        atScore:      n => `at ${n}`,
        // gameover
        gameOver:     'game over',
        scoreLabel:   n => `score: ${n}`,
        newRecord:    'new record!',
        bestLabel:    n => `best: ${n}`,
        menu:         'menu',
        // help
        helpTitle:    'how to play',
        helpStep1:    '① cards appear automatically',
        helpStep2:    '② count the same symbols across all cards',
        helpStep3:    '③ exactly 5? → hit PLING!',
        helpStep4:    '④ wrong press → lose a ♥',
        helpExample:  'example:',
        helpPlus:     '+',
        helpEq:       (a, b, sym) => `${a} + ${b} ${sym} = ${a+b}`,
        helpYes:      '→ PLING! ✓',
        helpNo:       '→ no PLING ✗',
        helpBack:     '← back',
        helpNote:     'symbols and counts change every round',
        // lang toggle
        langLabel:    'DE',
      },
      de: {
        // menu
        howTo1:       'Zähle Symbole auf allen Karten zusammen',
        howTo2:       'Genau 5 gleiche? → PLING drücken!',
        howTo3prefix: 'Falsch gedrückt → Herz verlieren ',
        tagline:      'Wie viele schaffst du?',
        best:         n => `Rekord: ${n}`,
        start:        'Start',
        // countdown
        ready:        'bereit?',
        go:           'los!',
        // game
        rule:         'genau 5 gleiche → pling!',
        atScore:      n => `ab ${n}`,
        // gameover
        gameOver:     'Game Over',
        scoreLabel:   n => `Punkte: ${n}`,
        newRecord:    'Neuer Rekord!',
        bestLabel:    n => `Rekord: ${n}`,
        menu:         'Menü',
        // help
        helpTitle:    'Spielanleitung',
        helpStep1:    '① Karten erscheinen automatisch',
        helpStep2:    '② Zähle gleiche Symbole auf allen Karten',
        helpStep3:    '③ Genau 5? → PLING drücken!',
        helpStep4:    '④ Falsch gedrückt → ♥ verlieren',
        helpExample:  'Beispiel:',
        helpPlus:     '+',
        helpEq:       (a, b, sym) => `${a} + ${b} ${sym} = ${a+b}`,
        helpYes:      '→ PLING! ✓',
        helpNo:       '→ kein PLING ✗',
        helpBack:     '← zurück',
        helpNote:     'Symbole und Zahlen ändern sich jede Runde',
        // lang toggle
        langLabel:    'EN',
      }
    };

    function t(key, ...args) {
      const val = T[lang][key];
      return typeof val === 'function' ? val(...args) : val;
    }

    // ─── Symbols ─────────────────────────────────────────────────────────────────

    const SYMBOLS = ['●', '■', '▲'];

    // ─── State ───────────────────────────────────────────────────────────────────

    // gameState: 'menu' | 'countdown' | 'playing' | 'feedback' | 'gameover' | 'help'
    let gameState = 'menu';
    let countdownText = '';
    let countdownTimer = null;
    let currentStackIndex = 0;
    let stacks = [null, null, null, null];
    let activeStacks = 2;
    let gameLoop = null;
    let lastResult = null; // 'correct' | 'wrong'
    let lives = 3;
    let score = 0;
    let highScore = parseInt(localStorage.getItem('highScore') || '0', 10);

    const MAX_LIVES = 3;


    // ─── Card flashes ────────────────────────────────────────────────────────────

    let cardFlashes = [];

    function addCardFlash(index) {
      cardFlashes = cardFlashes.filter(f => f.index !== index);
      cardFlashes.push({ index, opacity: 1 });
    }

    function updateCardFlashes() {
      cardFlashes = cardFlashes.filter(f => f.opacity > 0);
      for (const f of cardFlashes) f.opacity -= 0.04;
    }

    function getCardFlash(index) {
      return cardFlashes.find(f => f.index === index) || null;
    }

    // ─── Ripples ─────────────────────────────────────────────────────────────────

    let ripples = [];

    function addRipple(x, y) {
      ripples.push({ x, y, radius: BELL_RADIUS, opacity: 0.8 });
    }

    function updateRipples() {
      ripples = ripples.filter(r => r.opacity > 0);
      for (const r of ripples) {
        r.radius += 4;
        r.opacity -= 0.025;
      }
    }

    function drawRipples() {
      for (const r of ripples) {
        ctx.beginPath();
        ctx.arc(r.x, r.y, r.radius, 0, Math.PI * 2);
        ctx.strokeStyle = `rgba(255, 255, 255, ${r.opacity})`;
        ctx.lineWidth = 1.5;
        ctx.stroke();
      }
    }

    // ─── Layout ──────────────────────────────────────────────────────────────────

    function getLayout() {
      const cx = canvas.width / 2;
      const cy = canvas.height / 2;

      const scoreH        = 24;
      const scoreGap      = 16;
      const cardBellGap   = 28;
      const bellHeartsGap = 20;
      const heartsH       = 24;

      const zoneH = scoreH + scoreGap + CARD_HEIGHT + cardBellGap + BELL_RADIUS * 2 + bellHeartsGap + heartsH;
      const verticalOffset = 40;
      const zoneY = cy - zoneH / 2 + verticalOffset;

      const scoreY  = zoneY + scoreH / 2;
      const cardsY  = zoneY + scoreH + scoreGap;
      const bellY   = cardsY + CARD_HEIGHT + cardBellGap + BELL_RADIUS;
      const heartsY = bellY + BELL_RADIUS + bellHeartsGap;

      const totalCardsWidth = STACK_COUNT * CARD_WIDTH + (STACK_COUNT - 1) * CARD_GAP;
      const cardsStartX = cx - totalCardsWidth / 2;
      const cards = [];
      for (let i = 0; i < STACK_COUNT; i++) {
        cards.push({ x: cardsStartX + i * (CARD_WIDTH + CARD_GAP), y: cardsY });
      }

      const INFO_RADIUS = 22; // round info button radius

      return {
        cx,
        cy,
        scoreY,
        heartsY,
        cards,
        bell: { x: cx, y: bellY, radius: BELL_RADIUS },
        menuButton: {
          x: cx - BUTTON_WIDTH / 2,
          y: cy + 120,
          width: BUTTON_WIDTH,
          height: BUTTON_HEIGHT
        },
        // round ? button – bottom-right corner, same spot on every screen
        infoButton: {
          x: canvas.width - 20 - INFO_RADIUS,
          y: canvas.height - 20 - INFO_RADIUS,
          radius: INFO_RADIUS
        },
        langButton: {
          x: canvas.width - 60,
          y: 16,
          width: 44,
          height: 28
        },
        closeButton: { x: canvas.width - 56, y: 20, size: 36 },
        backButton: {
          x: 16,
          y: 16,
          width: 80,
          height: 32
        }
      };
    }

    // ─── Draw helpers ────────────────────────────────────────────────────────────

    function clearCanvas() {
      ctx.fillStyle = COLOR_BG;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
    }

    function drawText(text, x, y, { size = 24, color = COLOR_FG, align = 'center', baseline = 'middle' } = {}) {
      ctx.fillStyle = color;
      ctx.font = `${size}px ${FONT_MONO}`;
      ctx.textAlign = align;
      ctx.textBaseline = baseline;
      ctx.fillText(text, x, y);
    }

    function drawRect(x, y, w, h, { fill = COLOR_SURFACE, stroke = COLOR_BORDER, lineWidth = 1, radius = 0 } = {}) {
      ctx.fillStyle = fill;
      if (radius > 0) {
        ctx.beginPath();
        ctx.roundRect(x, y, w, h, radius);
        ctx.fill();
        ctx.strokeStyle = stroke;
        ctx.lineWidth = lineWidth;
        ctx.stroke();
      } else {
        ctx.fillRect(x, y, w, h);
        ctx.strokeStyle = stroke;
        ctx.lineWidth = lineWidth;
        ctx.strokeRect(x, y, w, h);
      }
    }

    // ─── Draw screens ────────────────────────────────────────────────────────────

    function drawLangToggle(layout) {
      const { langButton: lb } = layout;
      drawRect(lb.x, lb.y, lb.width, lb.height, { fill: COLOR_SURFACE, stroke: COLOR_BORDER, radius: 4 });
      drawText(t('langLabel'), lb.x + lb.width / 2, lb.y + lb.height / 2, { size: 12, color: COLOR_MUTED });
    }

    function drawInfoButton(layout) {
      const { x, y, radius } = layout.infoButton;
      ctx.beginPath();
      ctx.arc(x, y, radius, 0, Math.PI * 2);
      ctx.fillStyle = COLOR_SURFACE;
      ctx.fill();
      ctx.strokeStyle = COLOR_BORDER;
      ctx.lineWidth = 1;
      ctx.stroke();
      drawText('?', x, y, { size: 16, color: COLOR_MUTED });
    }

    function drawMenu() {
      const layout = getLayout();
      clearCanvas();

      // Title
      drawText('pling!', layout.cx, layout.cy - 110, { size: 72 });

      // How to play
      drawText(t('howTo1'), layout.cx, layout.cy - 35, { size: 13, color: COLOR_MUTED });
      drawText(t('howTo2'), layout.cx, layout.cy - 14, { size: 13, color: COLOR_MUTED });

      // "wrong press → lose a heart ♥" with colored heart
      const prefix = t('howTo3prefix');
      const heart = '♥';
      ctx.font = `13px ${FONT_MONO}`;
      const totalWidth = ctx.measureText(prefix + heart).width;
      const textStartX = layout.cx - totalWidth / 2;
      ctx.textAlign = 'left';
      ctx.textBaseline = 'middle';
      ctx.fillStyle = COLOR_MUTED;
      ctx.fillText(prefix, textStartX, layout.cy + 7);
      ctx.fillStyle = COLOR_RED;
      ctx.fillText(heart, textStartX + ctx.measureText(prefix).width, layout.cy + 7);

      // High score
      drawText(t('tagline'), layout.cx, layout.cy + 45, { size: 13, color: COLOR_SUBTLE });
      drawText(t('best', highScore), layout.cx, layout.cy + 68, { size: 20, color: COLOR_MUTED });

      // Start button – inverted
      const btn = layout.menuButton;
      ctx.fillStyle = COLOR_FG;
      ctx.fillRect(btn.x, btn.y, btn.width, btn.height);
      drawText(t('start'), btn.x + btn.width / 2, btn.y + btn.height / 2, { color: COLOR_BG });

      // Language toggle (top right)
      drawLangToggle(layout);

      // Info button (bottom right)
      drawInfoButton(layout);


    }

    function drawCountdown() {
      const layout = getLayout();
      clearCanvas();
      drawText(countdownText, layout.cx, layout.cy, { size: 64 });
    }

    function drawLockedCard(x, y, threshold) {
      drawRect(x, y, CARD_WIDTH, CARD_HEIGHT, { fill: COLOR_BG, stroke: '#21262d' });
      drawText('+', x + CARD_WIDTH / 2, y + CARD_HEIGHT / 2 - 14, { size: 22, color: '#30363d' });
      drawText(t('atScore', threshold), x + CARD_WIDTH / 2, y + CARD_HEIGHT / 2 + 14, { size: 10, color: '#30363d' });
    }

    function drawCard(x, y, card, index) {
      drawRect(x, y, CARD_WIDTH, CARD_HEIGHT, {
        fill: card ? COLOR_SURFACE : COLOR_BG,
        stroke: card ? COLOR_BORDER : '#21262d',
        lineWidth: 1
      });

      if (card) {
        const padding = 28;
        const cx = x + CARD_WIDTH / 2;
        const cy = y + CARD_HEIGHT / 2;
        const ox = CARD_WIDTH / 2 - padding;
        const oy = CARD_HEIGHT / 2 - padding;

        const positions = {
          1: [[0, 0]],
          2: [[-ox, -oy], [ox, oy]],
          3: [[-ox, -oy], [0, 0], [ox, oy]],
          4: [[-ox, -oy], [ox, -oy], [-ox, oy], [ox, oy]]
        };

        for (const [dx, dy] of positions[card.count]) {
          drawText(card.symbol, cx + dx, cy + dy, { size: 20 });
        }
      }

      const flash = getCardFlash(index);
      if (flash) {
        ctx.strokeStyle = `rgba(255, 255, 255, ${flash.opacity})`;
        ctx.lineWidth = 2;
        ctx.strokeRect(x, y, CARD_WIDTH, CARD_HEIGHT);
      }
    }

    function drawBell(bell) {
      let fill = COLOR_SURFACE;
      let stroke = COLOR_BORDER;
      let labelColor = COLOR_FG;
      let label = 'pling!';
      let labelSize = 18;

      if (gameState === 'feedback') {
        if (lastResult === 'correct') {
          fill = '#0d1f3c';
          stroke = COLOR_CORRECT;
          label = '✓';
          labelColor = COLOR_CORRECT;
          labelSize = 32;
        } else {
          fill = '#2d1f0a';
          stroke = COLOR_WRONG;
          label = '✗';
          labelColor = COLOR_WRONG;
          labelSize = 32;
        }
      }

      ctx.beginPath();
      ctx.arc(bell.x, bell.y, bell.radius, 0, Math.PI * 2);
      ctx.fillStyle = fill;
      ctx.fill();
      ctx.strokeStyle = stroke;
      ctx.lineWidth = 1.5;
      ctx.stroke();

      ctx.font = `${labelSize}px ${FONT_MONO}`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillStyle = labelColor;
      ctx.fillText(label, bell.x, bell.y);
    }

    function drawLives(x, y) {
      const full = '♥';
      const empty = '♡';
      let hearts = '';
      for (let i = 0; i < MAX_LIVES; i++) {
        hearts += i < lives ? full : empty;
        if (i < MAX_LIVES - 1) hearts += ' ';
      }
      drawText(hearts, x, y, { size: 20, color: COLOR_RED });
    }

    function drawGame() {
      const layout = getLayout();
      clearCanvas();

      for (let i = 0; i < STACK_COUNT; i++) {
        if (i < activeStacks) {
          drawCard(layout.cards[i].x, layout.cards[i].y, stacks[i], i);
        } else {
          drawLockedCard(layout.cards[i].x, layout.cards[i].y, UNLOCK_THRESHOLDS[i - 2]);
        }
      }

      drawRipples();
      drawBell(layout.bell);

      // Close button
      drawRect(layout.closeButton.x, layout.closeButton.y, layout.closeButton.size, layout.closeButton.size, {
        fill: COLOR_BG,
        stroke: COLOR_BORDER
      });
      drawText('×', layout.closeButton.x + layout.closeButton.size / 2, layout.closeButton.y + layout.closeButton.size / 2, { size: 18, color: COLOR_MUTED });

      drawText(`${score}`, layout.cx, layout.scoreY, { size: 32, color: COLOR_SUBTLE });
      drawLives(layout.cx, layout.heartsY);
      drawText(t('rule'), layout.cx, canvas.height - 28, { size: 11, color: COLOR_SUBTLE });

      // Info button (bottom right)
      drawInfoButton(layout);
    }

    function drawGameOver() {
      const layout = getLayout();
      clearCanvas();

      drawText(t('gameOver'), layout.cx, layout.cy - 90, { size: 36 });
      drawText(t('scoreLabel', score), layout.cx, layout.cy - 20, { size: 28 });

      if (score > 0 && score === highScore) {
        drawText(t('newRecord'), layout.cx, layout.cy + 25, { size: 14, color: COLOR_CORRECT });
      } else {
        drawText(t('bestLabel', highScore), layout.cx, layout.cy + 25, { size: 14, color: COLOR_SUBTLE });
      }

      const btn = layout.menuButton;
      ctx.fillStyle = COLOR_FG;
      ctx.fillRect(btn.x, btn.y, btn.width, btn.height);
      drawText(t('menu'), btn.x + btn.width / 2, btn.y + btn.height / 2, { color: COLOR_BG });

      // Info button (bottom right)
      drawInfoButton(layout);
    }

    // ─── Help screen ─────────────────────────────────────────────────────────────

    // Draws a mini card (scaled down) for help examples
    function drawMiniCard(x, y, card, w, h) {
      drawRect(x, y, w, h, { fill: COLOR_SURFACE, stroke: COLOR_BORDER });
      if (!card) return;

      const padding = 14;
      const cx = x + w / 2;
      const cy = y + h / 2;
      const ox = w / 2 - padding;
      const oy = h / 2 - padding;

      const positions = {
        1: [[0, 0]],
        2: [[-ox, -oy], [ox, oy]],
        3: [[-ox, -oy], [0, 0], [ox, oy]],
        4: [[-ox, -oy], [ox, -oy], [-ox, oy], [ox, oy]]
      };

      for (const [dx, dy] of positions[card.count]) {
        drawText(card.symbol, cx + dx, cy + dy, { size: 14 });
      }
    }

    // Draws one example row: [card1] + [card2] = total → result label
    function drawHelpExample(cx, y, card1, card2, isPling) {
      const W = 62, H = 90;
      const gap = 10;
      const totalRowW = W + gap + 18 + gap + W; // card + "+" + card
      const startX = cx - totalRowW / 2;

      drawMiniCard(startX, y, card1, W, H);

      // "+" between cards
      drawText('+', startX + W + gap / 2 + 9, y + H / 2, { size: 18, color: COLOR_SUBTLE });

      drawMiniCard(startX + W + gap + 18 + gap, y, card2, W, H);

      // Count equation below cards
      const total = card1.count + card2.count;
      const sym = card1.symbol;
      const eqText = `${card1.count} + ${card2.count} ${sym} = ${total}`;
      drawText(eqText, cx, y + H + 18, { size: 13, color: COLOR_MUTED });

      // Result
      const resultText = isPling ? t('helpYes') : t('helpNo');
      const resultColor = isPling ? COLOR_CORRECT : COLOR_WRONG;
      drawText(resultText, cx, y + H + 38, { size: 14, color: resultColor });
    }

    function drawHelp() {
      const layout = getLayout();
      clearCanvas();

      const cx = layout.cx;

      // Vertical centering: measure total content height, then compute start y
      // so the block is centered between the nav bar and the bottom of the canvas.
      const CONTENT_H = 518; // title center → note bottom (measured layout)
      const navBottom = 56;  // back button bottom + small gap
      const bottomPad = 20;
      let y = navBottom + Math.max(0, (canvas.height - navBottom - bottomPad - CONTENT_H) / 2);

      // Back button (top left)
      const bb = layout.backButton;
      drawRect(bb.x, bb.y, bb.width, bb.height, { fill: COLOR_SURFACE, stroke: COLOR_BORDER, radius: 4 });
      drawText(t('helpBack'), bb.x + bb.width / 2, bb.y + bb.height / 2, { size: 12, color: COLOR_MUTED });

      // Language toggle (top right)
      drawLangToggle(layout);

      // Title
      drawText(t('helpTitle'), cx, y, { size: 26 });
      y += 44;

      // Steps
      const steps = [t('helpStep1'), t('helpStep2'), t('helpStep3'), t('helpStep4')];
      for (const step of steps) {
        drawText(step, cx, y, { size: 13, color: COLOR_MUTED });
        y += 22;
      }

      y += 18;

      // Divider
      ctx.strokeStyle = COLOR_BORDER;
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(cx - 140, y);
      ctx.lineTo(cx + 140, y);
      ctx.stroke();
      y += 18;

      // "example:" label
      drawText(t('helpExample'), cx, y, { size: 13, color: COLOR_SUBTLE });
      y += 22;

      // Example 1: 3 ● + 2 ● = 5 → PLING!
      const ex1card1 = { symbol: '●', count: 3 };
      const ex1card2 = { symbol: '●', count: 2 };
      drawHelpExample(cx, y, ex1card1, ex1card2, true);
      y += 90 + 50 + 14;

      // Example 2: 2 ■ + 1 ■ = 3 → no PLING
      const ex2card1 = { symbol: '■', count: 2 };
      const ex2card2 = { symbol: '■', count: 1 };
      drawHelpExample(cx, y, ex2card1, ex2card2, false);
      y += 90 + 50 + 22;

      // Note
      drawText(t('helpNote'), cx, y, { size: 11, color: COLOR_SUBTLE });
    }

    // ─── Main draw ───────────────────────────────────────────────────────────────

    function draw() {
      if (gameState === 'menu') {
        drawMenu();
      } else if (gameState === 'countdown') {
        drawCountdown();
      } else if (gameState === 'playing' || gameState === 'feedback') {
        drawGame();
      } else if (gameState === 'gameover') {
        drawGameOver();
      } else if (gameState === 'help') {
        drawHelp();
      }
    }

    // ─── Animation loop ──────────────────────────────────────────────────────────

    function loop() {
      updateRipples();
      updateCardFlashes();
      draw();
      requestAnimationFrame(loop);
    }

    // ─── Game logic ──────────────────────────────────────────────────────────────

    function getInterval() {
      return Math.max(MIN_INTERVAL, BASE_INTERVAL - score * 40);
    }

    function randomCard() {
      const symbol = SYMBOLS[Math.floor(Math.random() * SYMBOLS.length)];
      const count = Math.floor(Math.random() * 4) + 1;
      return { symbol, count };
    }

    function addNextCard() {
      addCardFlash(currentStackIndex);
      stacks[currentStackIndex] = randomCard();
      currentStackIndex = (currentStackIndex + 1) % activeStacks;
    }

    function countSymbols() {
      const counts = {};
      for (const s of SYMBOLS) counts[s] = 0;
      for (const card of stacks) {
        if (card) counts[card.symbol] += card.count;
      }
      return counts;
    }

    function hasExactlyFive() {
      const counts = countSymbols();
      return SYMBOLS.some(s => counts[s] === 5);
    }

    // ─── Transitions ─────────────────────────────────────────────────────────────

    function goToMenu() {
      if (gameLoop) { clearTimeout(gameLoop); gameLoop = null; }
      if (countdownTimer) { clearTimeout(countdownTimer); countdownTimer = null; }
      ripples = [];
      cardFlashes = [];
      stacks = [null, null, null, null];
      activeStacks = 2;
      currentStackIndex = 0;
      lastResult = null;
      gameState = 'menu';
    }

    function goToGameOver() {
      if (gameLoop) { clearTimeout(gameLoop); gameLoop = null; }
      if (score > highScore) {
        highScore = score;
        localStorage.setItem('highScore', highScore);
      }
      gameState = 'gameover';
    }

    function startCountdown() {
      gameState = 'countdown';
      lives = MAX_LIVES;
      score = 0;
      activeStacks = 2;

      const steps = [
        { text: t('ready'), duration: 700 },
        { text: t('go'),    duration: 500 }
      ];

      function runStep(index) {
        if (index >= steps.length) {
          countdownTimer = null;
          startPlaying();
          return;
        }
        const step = steps[index];
        countdownText = step.text;
        countdownTimer = setTimeout(() => runStep(index + 1), step.duration);
      }
      runStep(0);
    }

    function checkUnlock() {
      let newActive = 2;
      for (const threshold of UNLOCK_THRESHOLDS) {
        if (score >= threshold) newActive++;
      }
      newActive = Math.min(newActive, STACK_COUNT);
      if (newActive > activeStacks) {
        activeStacks = newActive;
        addCardFlash(activeStacks - 1);
      }
    }

    function scheduleNextCard() {
      gameLoop = setTimeout(() => {
        addNextCard();
        if (gameState === 'playing') scheduleNextCard();
      }, getInterval());
    }

    function startPlaying() {
      gameState = 'playing';
      stacks = [null, null, null, null];
      currentStackIndex = 0;
      scheduleNextCard();
    }

    function checkPling(x, y) {
      if (gameLoop) { clearTimeout(gameLoop); gameLoop = null; }

      lastResult = hasExactlyFive() ? 'correct' : 'wrong';
      if (lastResult === 'correct') { score++; checkUnlock(); }
      if (lastResult === 'wrong') lives--;

      addRipple(x, y);
      gameState = 'feedback';

      setTimeout(() => {
        if (lives === 0) {
          goToGameOver();
        } else {
          startPlaying();
        }
      }, FEEDBACK_DURATION);
    }

    // ─── Input ───────────────────────────────────────────────────────────────────

    function isInside(x, y, rect) {
      return x >= rect.x && x <= rect.x + (rect.width || rect.size) &&
             y >= rect.y && y <= rect.y + (rect.height || rect.size);
    }

    function isInsideCircle(x, y, circle) {
      const dx = x - circle.x;
      const dy = y - circle.y;
      return Math.sqrt(dx * dx + dy * dy) <= circle.radius;
    }

    function isInsideBell(x, y, bell) {
      return isInsideCircle(x, y, bell);
    }

    function toggleLang() {
      lang = lang === 'en' ? 'de' : 'en';
      localStorage.setItem('lang', lang);
      document.documentElement.lang = lang;
    }

    function handlePress(x, y) {
      const layout = getLayout();

      if (gameState === 'menu') {
        if (isInside(x, y, layout.langButton))        { toggleLang(); return; }
        if (isInsideCircle(x, y, layout.infoButton))  { gameState = 'help'; return; }
        if (isInside(x, y, layout.menuButton))        { startCountdown(); return; }

      } else if (gameState === 'help') {
        if (isInside(x, y, layout.langButton))  { toggleLang(); return; }
        if (isInside(x, y, layout.backButton))  { gameState = 'menu'; return; }

      } else if (gameState === 'playing') {
        if (isInside(x, y, layout.closeButton))       { goToMenu(); return; }
        if (isInsideCircle(x, y, layout.infoButton))  { goToMenu(); gameState = 'help'; return; }
        if (isInsideBell(x, y, layout.bell))          { checkPling(layout.bell.x, layout.bell.y); return; }

      } else if (gameState === 'gameover') {
        if (isInsideCircle(x, y, layout.infoButton))  { gameState = 'help'; return; }
        if (isInside(x, y, layout.menuButton))        { goToMenu(); return; }
      }
    }

    function getCanvasCoords(clientX, clientY) {
      const rect = canvas.getBoundingClientRect();
      return { x: clientX - rect.left, y: clientY - rect.top };
    }

    canvas.addEventListener('click', (e) => {
      const { x, y } = getCanvasCoords(e.clientX, e.clientY);
      handlePress(x, y);
    });

    canvas.addEventListener('touchstart', (e) => {
      e.preventDefault();
      const t = e.touches[0];
      const { x, y } = getCanvasCoords(t.clientX, t.clientY);
      handlePress(x, y);
    });

    function resizeCanvas() {
      canvas.width  = Math.min(window.innerWidth,  430);
      canvas.height = Math.min(window.innerHeight, 932);
    }

    window.addEventListener('resize', () => {
      resizeCanvas();
      draw();
    });

    // ─── Init ────────────────────────────────────────────────────────────────────

    resizeCanvas();
    loop();

    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('./sw.js');
    }
  </script>
</body>
</html>
