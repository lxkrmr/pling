<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>pling</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background: #1a1a1a;
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    canvas {
      display: block;
    }
  </style>
</head>
<body>
  <canvas id="game"></canvas>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    // ─── Constants ───────────────────────────────────────────────────────────────

    const CARD_WIDTH = 100;
    const CARD_HEIGHT = 140;
    const CARD_GAP = 20;
    const BUTTON_WIDTH = 200;
    const BUTTON_HEIGHT = 80;
    const CARD_INTERVAL = 1000; // ms between cards
    const FEEDBACK_DURATION = 1000; // ms to show correct/wrong

    const FONT_MONO = '"SF Mono", Monaco, Inconsolata, "Fira Code", monospace';
    const COLOR_BG = '#1a1a1a';
    const COLOR_FG = '#e0e0e0';
    const COLOR_DIM = '#444';
    const COLOR_DIMMER = '#333';

    // ─── Symbols ─────────────────────────────────────────────────────────────────

    const SYMBOLS = ['●', '■', '▲'];

    // ─── State ───────────────────────────────────────────────────────────────────

    // gameState: 'menu' | 'countdown' | 'playing' | 'feedback'
    let gameState = 'menu';
    let countdownValue = 3;
    let countdownTimer = null;
    let currentStackIndex = 0;
    let stacks = [null, null, null];
    let gameLoop = null;
    let lastResult = null; // 'correct' | 'wrong'
    let lives = 3;
    let score = 0;
    let highScore = 0;

    const MAX_LIVES = 3;

    // ─── Layout ──────────────────────────────────────────────────────────────────

    function getLayout() {
      const totalCardsWidth = 3 * CARD_WIDTH + 2 * CARD_GAP;
      const cx = canvas.width / 2;
      const cy = canvas.height / 2;

      const cardsY = cy - CARD_HEIGHT / 2 - 40;
      const buttonY = cy + CARD_HEIGHT / 2 + 20;
      const cardsStartX = cx - totalCardsWidth / 2;

      return {
        cx,
        cy,
        cards: [
          { x: cardsStartX, y: cardsY },
          { x: cardsStartX + CARD_WIDTH + CARD_GAP, y: cardsY },
          { x: cardsStartX + 2 * (CARD_WIDTH + CARD_GAP), y: cardsY }
        ],
        button: {
          x: cx - BUTTON_WIDTH / 2,
          y: buttonY,
          width: BUTTON_WIDTH,
          height: BUTTON_HEIGHT
        },
        closeButton: {
          x: canvas.width - 60,
          y: 20,
          size: 40
        }
      };
    }

    // ─── Draw helpers ────────────────────────────────────────────────────────────

    function clearCanvas() {
      ctx.fillStyle = COLOR_BG;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
    }

    function drawText(text, x, y, { size = 24, color = COLOR_FG, align = 'center', baseline = 'middle' } = {}) {
      ctx.fillStyle = color;
      ctx.font = `${size}px ${FONT_MONO}`;
      ctx.textAlign = align;
      ctx.textBaseline = baseline;
      ctx.fillText(text, x, y);
    }

    function drawRect(x, y, w, h, { fill = '#2a2a2a', stroke = COLOR_DIM, lineWidth = 2 } = {}) {
      ctx.fillStyle = fill;
      ctx.fillRect(x, y, w, h);
      ctx.strokeStyle = stroke;
      ctx.lineWidth = lineWidth;
      ctx.strokeRect(x, y, w, h);
    }

    // ─── Draw screens ────────────────────────────────────────────────────────────

    function drawMenu() {
      const layout = getLayout();
      clearCanvas();

      // Title
      drawText('pling!', layout.cx, layout.cy - 100, { size: 64 });

      // How to play
      drawText('count symbols across all cards', layout.cx, layout.cy - 30, { size: 14, color: '#666' });
      drawText('spot exactly 5 of a kind → PLING!', layout.cx, layout.cy - 8, { size: 14, color: '#666' });
      drawText('wrong press → lose a heart ♥', layout.cx, layout.cy + 14, { size: 14, color: '#666' });

      // High score
      drawText('how many can you get?', layout.cx, layout.cy + 42, { size: 14, color: '#555' });
      drawText(`best: ${highScore}`, layout.cx, layout.cy + 65, { size: 18, color: '#888' });

      // Start button (fixed position below content)
      const btnY = layout.cy + 110;
      drawRect(layout.cx - BUTTON_WIDTH / 2, btnY, BUTTON_WIDTH, BUTTON_HEIGHT);
      drawText('start', layout.cx, btnY + BUTTON_HEIGHT / 2);
    }

    function drawCountdown() {
      const layout = getLayout();
      clearCanvas();

      drawText(String(countdownValue), layout.cx, layout.cy, { size: 128 });
    }

    function drawCard(x, y, card) {
      drawRect(x, y, CARD_WIDTH, CARD_HEIGHT, {
        fill: card ? '#2a2a2a' : '#222',
        stroke: card ? COLOR_DIM : COLOR_DIMMER
      });

      if (card) {
        const padding = 28;
        const cx = x + CARD_WIDTH / 2;
        const cy = y + CARD_HEIGHT / 2;
        const ox = CARD_WIDTH / 2 - padding;
        const oy = CARD_HEIGHT / 2 - padding;

        // Dice-style positions
        const positions = {
          1: [[0, 0]],
          2: [[-ox, -oy], [ox, oy]],
          3: [[-ox, -oy], [0, 0], [ox, oy]],
          4: [[-ox, -oy], [ox, -oy], [-ox, oy], [ox, oy]]
        };

        for (const [dx, dy] of positions[card.count]) {
          drawText(card.symbol, cx + dx, cy + dy, { size: 20 });
        }
      }
    }

    function drawPlingButton(btn) {
      let fill = '#2a2a2a';
      let stroke = COLOR_DIM;
      let color = COLOR_FG;
      let text = 'PLING!';

      if (gameState === 'feedback') {
        if (lastResult === 'correct') {
          fill = '#166534';
          stroke = '#22c55e';
          color = '#4ade80';
          text = 'correct!';
        } else {
          fill = '#7f1d1d';
          stroke = '#ef4444';
          color = '#f87171';
          text = 'wrong!';
        }
      }

      drawRect(btn.x, btn.y, btn.width, btn.height, { fill, stroke });
      drawText(text, btn.x + btn.width / 2, btn.y + btn.height / 2, { color });
    }

    function drawCloseButton(cb) {
      drawRect(cb.x, cb.y, cb.size, cb.size, { fill: '#2a2a2a', stroke: COLOR_DIM });
      drawText('×', cb.x + cb.size / 2, cb.y + cb.size / 2, { size: 20, color: '#888' });
    }

    function drawGameOver() {
      const layout = getLayout();
      clearCanvas();

      drawText('game over', layout.cx, layout.cy - 100, { size: 40 });
      drawText(`score: ${score}`, layout.cx, layout.cy - 30, { size: 28 });

      if (score > 0 && score === highScore) {
        drawText('new record!', layout.cx, layout.cy + 20, { size: 18, color: '#4ade80' });
      } else if (highScore > 0) {
        drawText(`best: ${highScore}`, layout.cx, layout.cy + 20, { size: 18, color: '#888' });
      }

      // Back to menu button
      const btn = layout.button;
      drawRect(btn.x, btn.y, btn.width, btn.height);
      drawText('menu', btn.x + btn.width / 2, btn.y + btn.height / 2);
    }

    function drawLives() {
      const full = '♥';
      const empty = '♡';
      let hearts = '';
      for (let i = 0; i < MAX_LIVES; i++) {
        hearts += i < lives ? full : empty;
        if (i < MAX_LIVES - 1) hearts += ' ';
      }
      drawText(hearts, 20, 40, { size: 24, color: '#e05555', align: 'left' });
    }

    function drawGame() {
      const layout = getLayout();
      clearCanvas();

      // Cards
      for (let i = 0; i < 3; i++) {
        drawCard(layout.cards[i].x, layout.cards[i].y, stacks[i]);
      }

      // PLING button
      drawPlingButton(layout.button);

      // Close button
      drawCloseButton(layout.closeButton);

      // Lives
      drawLives();

      // Score (top center)
      drawText(`${score}`, layout.cx, 40, { size: 24, color: '#888' });
    }

    // ─── Main draw ───────────────────────────────────────────────────────────────

    function draw() {
      if (gameState === 'menu') {
        drawMenu();
      } else if (gameState === 'countdown') {
        drawCountdown();
      } else if (gameState === 'playing' || gameState === 'feedback') {
        drawGame();
      } else if (gameState === 'gameover') {
        drawGameOver();
      }
    }

    // ─── Game logic ──────────────────────────────────────────────────────────────

    function randomCard() {
      const symbol = SYMBOLS[Math.floor(Math.random() * SYMBOLS.length)];
      const count = Math.floor(Math.random() * 4) + 1; // 1–4
      return { symbol, count };
    }

    function addNextCard() {
      stacks[currentStackIndex] = randomCard();
      currentStackIndex = (currentStackIndex + 1) % 3;
      draw();
    }

    function countSymbols() {
      const counts = {};
      for (const s of SYMBOLS) counts[s] = 0;
      for (const card of stacks) {
        if (card) counts[card.symbol] += card.count;
      }
      return counts;
    }

    function hasExactlyFive() {
      const counts = countSymbols();
      return SYMBOLS.some(s => counts[s] === 5);
    }

    // ─── Transitions ─────────────────────────────────────────────────────────────

    function goToMenu() {
      // Stop everything
      if (gameLoop) { clearInterval(gameLoop); gameLoop = null; }
      if (countdownTimer) { clearInterval(countdownTimer); countdownTimer = null; }

      stacks = [null, null, null];
      currentStackIndex = 0;
      lastResult = null;
      gameState = 'menu';
      draw();
    }

    function startCountdown() {
      gameState = 'countdown';
      countdownValue = 3;
      lives = MAX_LIVES;
      score = 0;
      draw();

      countdownTimer = setInterval(() => {
        countdownValue--;
        if (countdownValue === 0) {
          clearInterval(countdownTimer);
          countdownTimer = null;
          startPlaying();
        } else {
          draw();
        }
      }, 1000);
    }

    function startPlaying() {
      gameState = 'playing';
      stacks = [null, null, null];
      currentStackIndex = 0;
      draw();

      gameLoop = setInterval(addNextCard, CARD_INTERVAL);
    }

    function checkPling() {
      if (gameLoop) { clearInterval(gameLoop); gameLoop = null; }

      lastResult = hasExactlyFive() ? 'correct' : 'wrong';
      if (lastResult === 'correct') score++;
      if (lastResult === 'wrong') lives--;

      gameState = 'feedback';
      draw();

      setTimeout(() => {
        if (lives === 0) {
          goToGameOver();
        } else {
          startPlaying(); // continue
        }
      }, FEEDBACK_DURATION);
    }

    function goToGameOver() {
      if (gameLoop) { clearInterval(gameLoop); gameLoop = null; }

      // Update high score
      if (score > highScore) highScore = score;

      gameState = 'gameover';
      draw();
    }

    // ─── Input ───────────────────────────────────────────────────────────────────

    function isInside(x, y, rect) {
      return x >= rect.x && x <= rect.x + (rect.width || rect.size) &&
             y >= rect.y && y <= rect.y + (rect.height || rect.size);
    }

    function handlePress(x, y) {
      const layout = getLayout();

      if (gameState === 'menu') {
        const menuBtn = { x: layout.cx - BUTTON_WIDTH / 2, y: layout.cy + 110, width: BUTTON_WIDTH, height: BUTTON_HEIGHT };
        if (isInside(x, y, menuBtn)) startCountdown();

      } else if (gameState === 'playing') {
        if (isInside(x, y, layout.closeButton)) goToMenu();
        else if (isInside(x, y, layout.button)) checkPling();

      } else if (gameState === 'feedback') {
        // ignore all input during feedback

      } else if (gameState === 'gameover') {
        if (isInside(x, y, layout.button)) goToMenu();
      }
    }

    canvas.addEventListener('click', (e) => handlePress(e.clientX, e.clientY));

    canvas.addEventListener('touchstart', (e) => {
      e.preventDefault();
      const t = e.touches[0];
      handlePress(t.clientX, t.clientY);
    });

    window.addEventListener('resize', () => {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      draw();
    });

    // ─── Init ────────────────────────────────────────────────────────────────────

    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    draw();
  </script>
</body>
</html>
